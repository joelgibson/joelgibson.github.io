<!DOCTYPE html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Characters of the Symmetric Group</title>
<meta name="author" content="Joel Gibson">
<meta name="description" content="An online calculator for Kronecker coefficients, which runs in the browser.">
<link rel="stylesheet" type="text/css" href="/style.css">
<link rel="stylesheet" href="/libraries/katex/katex.min.css">
<script type="text/javascript" src="/libraries/katex/katex.min.js"></script>
</head>
<body>
<header>
<a href="/" title="Home">Home</a>
</header>
<h1>Characters of the Symmetric Group</h1><p><style>#computationForm { line-height: 1.5em; }
#computationForm div { margin-bottom: 0.5em; }
#gln { width: 3em; font-size: 0.9em;}
input[type="radio"] { margin-left: 1em; }
#error { border: 1px solid red; }
.error { background-color: lightpink; }
.code { font-family: monospace; font-size: 1em; }
#computation { width: 100%; margin-left: 1em; }
#result, #errorInput { margin-left: 1em; }
table { margin-bottom: 2em; }

td, th { text-align: right; }
tr.character:hover { background-color: #3ff; }
tr.character.selected { background-color: #aff; }
td { width: 5em; height: 1.2em;}
tr.underlined td, tr.underlined th {border-bottom: 1px solid black;}
td.rightderlined { border-right: 1px solid black; }</style></p><p>This program computes character table of the symmetric group, and automatically decomposes tensor products of representations into their irreducible summands, i.e. it computes <a href="https://en.wikipedia.org/wiki/Kronecker_coefficient" target="_blank">Kronecker coefficients</a>. It can also decompose permutation modules (or tensor products of permutation modules) into irreducible components, and compute symmetric, exterior, and tensor powers of representations.</p><p>In the character table below, the rows and columns are labelled by partitions, written in compact notation where <math-inline>\lambda = [2^3, 1^2]</math-inline> means the partition <math-inline>\lambda = (2, 2, 2, 1, 1)</math-inline>. The rows correspond to characters (either irreducible characters for the Specht module <math-inline>S^\lambda</math-inline>, or the character of the permutation module <math-inline>M^\lambda</math-inline>), and the columns correspond to cycle types. The number of elements having a given cycle type is written at the top of each column. After selecting one or more rows, a second table will appear, decomposing the given character.</p><form autocomplete="off" id="computationForm"><div>Show characters for:<br/> <input checked="" id="specht" name="module-kind" type="radio" value="specht"><label for="specht"> the Specht (irreducible) modules</label></input> <br/> <input id="permutation" name="module-kind" type="radio" value="permutation"><label for="permutation"> the permutation modules</label></input> <br/> of the symmetric group on <math-inline>n = </math-inline> <input id="order" max="20" min="1" type="number" value="4"/> letters.</div></form><div id="tablePlace"></div><p><script src="characters.js" type="text/javascript"></script></p><h2>How does it work?</h2><p>The program is written in TypeScript, the source code is <a href="characters.ts">here</a>. The key data structure used throughout is a linear combination of partitions, which is represented as a map from partitions to numbers. (The code for this is awkward, since Javascript has no built-in data structure capable of storing and retrieving partitions, so I convert partitions to and from strings a lot). There are various helper functions for computing combinatorial information about partitions: for example computing the size of a conjugacy class labelled by a partition, which is used when computing the inner product on class functions. The interesting algorithms are explained below.</p><h2>Generating permutation characters</h2><p>First, the character table for the <em>permutation</em> modules is calculated. The column corresponding to the cycle type <math-inline>\mu = (\mu_1, \ldots, \mu_r)</math-inline> in this table is the expansion of the power sum symmetric function <math-inline>p_\mu</math-inline> into the basis of monomial symmetric functions. Since <math-inline>p_\mu = m_{(\mu_1)} \cdots m_{(\mu_r)}</math-inline> is a product of monomial symmetric functions with a single part, it suffices to have a rule to expand the product <math-inline>m_{(r)} m_{(\lambda_1, \ldots, \lambda_k)}</math-inline> as a sum of monomial symmetric functions, since we can then iterate this rule to recover the expansion of <math-inline>p_\mu</math-inline>. It is more convenient to use the <em>augmented</em> monomial functions <math-inline>M_\mu</math-inline>, which are scalings of the original functions <math-inline>m_\mu</math-inline> by an integer: if <math-inline>\mu = (1^{a_1}, 2^{a_2}, \ldots, k^{a_k})</math-inline> then <math-display>M_\mu = a_1! \cdots a_k! \, m_\mu.</math-display> The rule for the product <math-inline>m_{(r)} m_{(\lambda_1, \ldots, \lambda_k)}</math-inline> then takes a simple form: <math-display>m_{(r)} M_{(\lambda_1, \ldots, \lambda_k)} = M_{(r, \lambda_1, \ldots, \lambda_k)} + M_{(\lambda_1 + r, \ldots, \lambda_k)} + \cdots + M_{(\lambda_1, \ldots, \lambda_k + r)}</math-display> (where we need to sort the compositions appearing on the right hand side back into being partitions). Finally, after expanding <math-inline>p_\mu</math-inline> into a sum of the <math-inline>M_\lambda</math-inline>, we scale the coefficient of each <math-inline>M_\lambda</math-inline> to recover the decomposition of <math-inline>p_\mu</math-inline> into a sum of the <math-inline>m_\lambda</math-inline>, which is the <math-inline>\mu</math-inline> column of the permutation character table.</p><h2>Generating irreducible characters</h2><p>Denote the permutation modules <math-inline>M^\mu</math-inline>, and the irreducible modules <math-inline>S^\mu</math-inline>. These modules satisfy a unitriangularity property with respect to the dominance order on partitions: if the irreducible <math-inline>S^\lambda</math-inline> appears inside the permutation module <math-inline>M^\mu</math-inline>, then <math-inline>\mu</math-inline> dominates <math-inline>\lambda</math-inline>. The lexicographic order (the one used in the table) is a refinement of the dominance order, which means that for the row labelled by <math-inline>\lambda</math-inline>, the irreducible <math-inline>S^\lambda</math-inline> only appears in the permutation modules <math-inline>M^\mu</math-inline> for those <math-inline>\mu</math-inline> which are equal to or below <math-inline>\lambda</math-inline> in the table. Furthermore, <math-inline>S^\lambda</math-inline> appears in <math-inline>M^\lambda</math-inline> exactly once, and <math-inline>S^{(n)} = M^{(n)}</math-inline> (the top row of both tables are the same).</p><p>This gives an inductive way of transforming the permutation character table into the irreducible character table. Beginning with the first row (which is already irreducible), use the inner product on class functions to determine how often that irreducible appears in the lower rows. Then, subtract that irreducible from each of the lower rows as many times as it appeared in each row. After this is done, the second row must be irreducible, and we repeat the same process to the rows below the second (leaving the rows above untouched), until every row is irreducible.</p><h2>Computing tensor product decompositions</h2><p>Given two characters <math-inline>\chi_1</math-inline> and <math-inline>\chi_2</math-inline>, the character <math-inline>\chi_1 \otimes \chi_2</math-inline> corresponding to their tensor product is given by the pointwise product of class functions: <math-inline>(\chi_1 \otimes \chi_2)(g) = \chi_1(g) \chi_2(g)</math-inline>. In order to decompose this new class function back into a sum of irreducible characters, we use the inner product on class functions: <math-display> \chi_1 \otimes \chi_2 = \sum_{\lambda} (\chi_1 \otimes \chi_2, s_\lambda) s_\lambda. </math-display> Since we already have the entire character table available, it is straightforward to compute the numbers <math-inline>(\chi_1 \otimes \chi_2, s_\lambda)</math-inline> for each partition <math-inline>\lambda</math-inline> of <math-inline>n</math-inline>.</p><h2>Computing alternating, symmetric, and tensor powers</h2><p>Given a representation <math-inline>\rho: G \to \operatorname{End}_{\mathbb{C}}(V)</math-inline> of groups, we naturally obtain representations of <math-inline>G</math-inline> on the exterior powers <math-inline>\wedge^r(V)</math-inline>, the symmetric powers <math-inline>S^r(V)</math-inline>, and the tensor powers <math-inline>\otimes^r V</math-inline>, by functorality. If we only know the character <math-inline>\chi(g) = \operatorname{trace}(\rho(g))</math-inline> of the representation <math-inline>\rho</math-inline>, it is possible to compute the characters of the exterior, symmetric, and tensor powers.</p><p>The most straightforward to compute is the tensor power, since a tensor product of representations correpsonds to a pointwise product of characters. So if <math-inline>\chi</math-inline> is the character of <math-inline>V</math-inline>, then <math-inline>(\otimes^r \chi)(g) = \chi(g)^r</math-inline> is the character of <math-inline>\otimes^r(V)</math-inline>.</p><p>Now, consider the exterior power <math-inline>\wedge^r (V)</math-inline> and the symmetric power <math-inline>S^r(V)</math-inline>. For each group element <math-inline>g</math-inline>, we need to compute the trace of <math-inline>\rho(g)</math-inline> on <math-inline>\wedge^r (V)</math-inline> and on <math-inline>S^r(V)</math-inline>. The matrix <math-inline>\rho(g)</math-inline> has finite order, and hence diagonalises, say with eigenvalues <math-inline>\lambda_1, \ldots, \lambda_n</math-inline> (counted with multiplicity). By considering bases for <math-inline>\wedge^r (V)</math-inline> and <math-inline>S^r(V)</math-inline>, it is easy to see that <math-display>\operatorname{trace}(\rho(g) | \wedge^r A) = \sum_{1 \leq i_1 &lt; \cdots &lt; i_r \leq n} \lambda_{i_1} \cdots \lambda_{i_r} = e_r(\lambda_1, \ldots, \lambda_n),</math-display> <math-display>\operatorname{trace}(\rho(g) | S^r A) = \sum_{1 \leq i_1 \leq \cdots \leq i_r \leq n} \lambda_{i_1} \cdots \lambda_{i_r} = h_r(\lambda_1, \ldots, \lambda_n),</math-display> where <math-inline>e_r</math-inline> is the <math-inline>r</math-inline>th elementary symmetric function, and <math-inline>h_r</math-inline> is the <math-inline>r</math-inline>th complete symmetric function. Knowing this is not immediately helpful, since it’s still unclear how to produce (for example) the number <math-inline>e_r(\lambda_1, \ldots, \lambda_n)</math-inline> if all we know is the trace <math-inline>\chi(g) = \lambda_1 + \cdots + \lambda_n</math-inline>.</p><p>However, since the character <math-inline>\chi</math-inline> contains the trace of <em>every</em> group element, we can notice that <math-display> \operatorname{trace}(\rho(g)^r) = \sum_{1 \leq i \leq n} \lambda_i^r = p_r(\lambda_1, \ldots, \lambda_n), </math-display> where <math-inline>p_r</math-inline> is the <math-inline>r</math-inline>th power sum symmetric function. We can actually compute this value from <math-inline>\chi</math-inline>, since <math-inline>\rho(g)^r = \rho(g^r)</math-inline>, hence <math-inline>p_r(\lambda_1, \ldots, \lambda_n) = \chi(g^r)</math-inline>. In the case of symmetric groups, all that this requires knowing is how to compute “powers” of cycle types: if <math-inline>g \in S_n</math-inline> has cycle type <math-inline>\mu</math-inline>, then determine what the cycle type of <math-inline>g^r</math-inline> is.</p><p>Finally, in order to compute <math-inline>e_r(\lambda_1, \ldots, \lambda_n)</math-inline> and <math-inline>h_r(\lambda_1, \ldots, \lambda_n)</math-inline>, we use <a href="https://en.wikipedia.org/wiki/Newton%27s_identities" target="_blank">Newton’s identities</a> which express the (elementary / complete) symmetric functions in terms of power sums. For the elementary symmetric functions, the recurrence is <math-display> e_r = \frac{1}{r} \sum_{j = 1}^r (-1)^{r + 1} e_{r - j} p_j </math-display> which in terms of a character <math-inline>\chi</math-inline>, tells us that the character <math-inline>\wedge^r \chi</math-inline> corresponding to the <math-inline>r</math-inline>th exterior power <math-inline>\wedge^r V</math-inline> is given by <math-display> (\wedge^r \chi)(g) = \frac{1}{r} \sum_{j = 1}^r (-1)^{r + 1} (\wedge^{r - j} \chi)(g) \cdot \chi(g^j), </math-display> which requires knowing the class functions <math-inline>\wedge^0 \chi, \cdots, \wedge^{r-1} \chi</math-inline>. We begin the induction with <math-inline>\wedge^0 \chi</math-inline> being the trivial character, and then compute as many exterior powers as necessary.</p><p>Computing symmetric powers is almost the same as computing exterior powers; applying the <math-inline>\omega</math-inline> involution to the above recurrence for elementary symmetric functions gives <math-display> h_r = \frac{1}{r} \sum_{j = 1}^r h_{r - j} p_j,</math-display> allowing all of the characters <math-inline>S^r \chi</math-inline> to be computed in the same manner.</p>

<script type="text/javascript">
  function elemsByTagName(tag) {
    var elems = document.getElementsByTagName(tag);
    var list = [];
    for (var i = 0; i < elems.length; i++)
      list.push(elems[i]);
    return list;
  }

  elemsByTagName('math-inline').forEach(function(elem) {
    katex.render(elem.textContent, elem);
  });
  elemsByTagName('math-display').forEach(function(elem) {
    katex.render(elem.textContent, elem, {displayMode: true});
  });
</script>
</body>
</html>